#include "searchStateMachine.hpp"

#include "utilities.hpp"
#include "stateMachine.hpp"
#include "searchFromPathFile.hpp"

#include <cmath>
#include <utility>
#include <iostream>

// Constructs an SearchStateMachine object with mStateMachine, mConfig, and mRover
SearchStateMachine::SearchStateMachine(std::weak_ptr<StateMachine> sm, const rapidjson::Document& roverConfig)
        : mStateMachine(move(sm)), mConfig(roverConfig) {}

// Runs the search state machine through one iteration. This will be called by
// StateMachine  when NavState is in a search state. This will call the corresponding
// function based on the current state and return the next NavState
NavState SearchStateMachine::run() {
    switch (mStateMachine.lock()->getRover()->currentState()) {
        case NavState::Search: {
            return executeSearch();
        }
        case NavState::DriveToTarget: {
            return executeDriveToTarget();
        }
        default: {
            std::cerr << "Entered Unknown NavState in search state machine" << std::endl;
            return NavState::Unknown;
        }
    } // switch
} // run()

NavState SearchStateMachine::executeSearch() {
    std::shared_ptr<StateMachine> sm = mStateMachine.lock();
    std::shared_ptr<Rover> rover = sm->getRover();

    Target const& leftTarget = sm->getEnv()->getLeftTarget();
    Target const& rightTarget = sm->getEnv()->getLeftTarget();
    Waypoint const& lastWaypoint = sm->getCourseState()->getLastCompletedWaypoint();
    bool isGate = lastWaypoint.gate;
    if (isGate) {
        if (sm->getEnv()->hasGateLocation()) {
            return NavState::BeginGateSearch;
        }
    } else {
        // You may as well just go to the left post always
        bool isWantedTarget = lastWaypoint.id == leftTarget.id;
        if (leftTarget.distance >= 0.0 && isWantedTarget) {
            return NavState::DriveToTarget;
        }
    }

    Odometry const& nextSearchPoint = mSearchPoints.front();
    double dt = sm->getDtSeconds();
    if (rover->turn(nextSearchPoint, dt)) {
        DriveStatus driveStatus = rover->drive(nextSearchPoint, dt, mConfig["navThresholds"]["waypointDistance"].GetDouble());
        if (driveStatus == DriveStatus::Arrived) {
            mSearchPoints.pop_front();
        }
    }
    return NavState::Search;
} // executeSearch()

NavState SearchStateMachine::executeDriveToTarget() {
    std::shared_ptr<StateMachine> sm = mStateMachine.lock();
    std::shared_ptr<Environment> env = sm->getEnv();
    std::shared_ptr<Rover> rover = sm->getRover();

    double dt = sm->getDtSeconds();
    Waypoint targetWaypoint = sm->getCourseState()->getNextWaypoint();
    Target const& leftTarget = env->getLeftTarget();
    Target const& rightTarget = env->getRightTarget();
    double currentBearing = rover->odometry().bearing_deg;

    double distance, bearing;
    if (targetWaypoint.gate) {
        Target target{};
        if (hasTargetWithId(targetWaypoint.id, target)) {
            distance = target.distance;
            bearing = target.bearing + currentBearing;
        } else {
            return NavState::Search;
        }
    } else {
        if (leftTarget.distance >= 0.0) {
            distance = leftTarget.distance;
            bearing = leftTarget.bearing + currentBearing;
        } else {
            std::cerr << "Lost the target" << std::endl;
            return NavState::Search;
        }
    }

    Odometry targetPoint = createOdom(rover->odometry(), bearing, distance, rover);

    if (rover->turn(targetPoint, dt)) {
        DriveStatus driveStatus = rover->drive(targetPoint, dt, mConfig["navThresholds"]["targetDistance"].GetDouble());
        if (driveStatus == DriveStatus::Arrived) {
            Waypoint completed = sm->getCourseState()->completeCurrentWaypoint();
            if (completed.gate) {
                return NavState::Done;
            } else {
                return NavState::Done;
            }
        }
    }

    return NavState::DriveToTarget;
} // executeDriveToTarget()

// add intermediate points between the existing search points in a path generated by a search algorithm.
// The maximum separation between any points in the search point list is determined by the rover's sight distance.
void SearchStateMachine::insertIntermediatePoints() {
//    double visionDistance = mConfig["computerVision"]["visionDistance"].GetDouble();
//    const double maxDifference = 2 * visionDistance;
//
//    for (int i = 0; i < int(mSearchPoints.size()) - 1; ++i) {
//        Odometry point1 = mSearchPoints.at(i);
//        Odometry point2 = mSearchPoints.at(i + 1);
//        double distance = estimateNoneuclid(point1, point2);
//        if (distance > maxDifference) {
//            int numPoints = int(ceil(distance / maxDifference) - 1);
//            double newDifference = distance / (numPoints + 1);
//            double bearing = calcBearing(point1, point2);
//            for (int j = 0; j < numPoints; ++j) {
//                Odometry startPoint = mSearchPoints.at(i);
//                Odometry newOdom = createOdom(startPoint, bearing, newDifference, mStateMachine.lock()->getRover());
//                auto insertPosition = mSearchPoints.begin() + i + 1;
//                mSearchPoints.insert(insertPosition, newOdom);
//                ++i;
//            }
//        }
//    }
} // insertIntermediatePoints()

bool SearchStateMachine::hasTargetWithId(int32_t id, Target& outTarget) {
    std::shared_ptr<Environment> env = mStateMachine.lock()->getEnv();
    Target const& leftTarget = env->getLeftTarget();
    Target const& rightTarget = env->getRightTarget();
    if (leftTarget.id == id && leftTarget.distance > 0.0) {
        outTarget = leftTarget;
        return true;
    } else if (rightTarget.id == id && rightTarget.distance > 0.0) {
        outTarget = rightTarget;
        return true;
    }
    return false;
}

// The search factory allows for the creation of search objects and
// an ease of transition between search algorithms
std::shared_ptr<SearchStateMachine>
SearchFactory(const std::weak_ptr<StateMachine>& sm, SearchType type, const std::shared_ptr<Rover>& rover, const rapidjson::Document& roverConfig) {
    std::shared_ptr<SearchStateMachine> search = nullptr;
    switch (type) {
        case SearchType::FROM_PATH_FILE:
            search = std::make_shared<SearchFromPathFile>(sm, roverConfig, "jetson/nav/search/spiral_search_points.txt");
            break;
        case SearchType::FROM_PATH_FILE_GATE:
            search = std::make_shared<SearchFromPathFile>(sm, roverConfig, "jetson/nav/search/gate_search_points.txt");
            break;
        default:
            std::cerr << "Unknown Search Type. Defaulting to Spiral\n";
            break;
    }
    return search;
} // SearchFactory

/******************/
/* TODOS */
/******************/
// save location of target then go around object? ( Execute drive to target )
// look into removing the waiting when turning to target or at least doing this a better way. This should at very least be it's own state
